### 第1章　オブジェクト指向設計

* オブジェクト指向設計とは「依存関係を管理すること」
* 設計の目的は「あとにでも」設計をできるようにすることであり、その第一目標は変更コストの削減
* SOLID
  * 単一責任(Single Responsibility)
  * オープン・クローズド
  * リスコフの置換(Liskov Substitution)
  * インターフェース分離(Interface Segregation)
  * 依存性逆転(Dependency Inversion)
* DRY(Don't Repeat Yourself)
* デメテルの法則
* 設計(デザイン)パターン
  * オブジェクト指向ソフトウェア設計におあて遭遇するさまざまな問題に対して、簡単でかつ明瞭な解を与える
  * 設計プロダクトの柔軟性、モジュール性、再利用性、および理解のしやすさをより高める

---

### 第2章　単一責任のクラスを設計する

* 設計とはアプリケーションの可変性を保つために技巧を凝らすことであり、完璧を目指すことではない
* 自身の書くコードには次の性質が伴うべき
  * 見通しがいい(Transparent)：変更するコードにおいても、そのコードに依存する別の場所のコードにおいても、その影響範囲が明白である
  * 合理的(Reasonable)：どんな変更であっても、かかるコストは変更がもたらす利益にふさわしい
  * 利用性が高い(Usable)：新しい環境、予期していなかった環境でも再利用できる
  * 模範的(Exemplary)：コードに変更を加える人が、上記の品質を自然と保つようなコードになっている
* 凝縮度：クラス内のすべてがそのクラスの中心的な目的に関連していればそのクラスは凝縮度が高い、もしくは、単一責任であると言われる
* 単一責任のメソッドがもたらす恩恵
  * 隠蔽されていた性質を明らかにする
  * コメントをする必要がない
  * 再利用を促進する
  * ほかのクラスへの移動が簡単

---

### 第3章　依存関係を管理する
* オブジェクトが次のものを知っているとき、オブジェクトには依存関係がある
  * ほかのクラスの名前
  * self以外のどこかに送ろうとするメッセージの名前
  * メッセージが要求する引数
  * それらの引数の順番
* ほかの依存関係
  * 「『何かを知るオブジェクト』を知るオブジェクト」を知るオブジェクトがあるとき
    * いくつものメッセージをチェーンでつなぐ場合など
  * テストからコードへの過度な結合
* 疎結合なコードを書く
  * 依存オブジェクトの注入
  * 依存を隔離する(不必要な依存を除去できないなら、クラス内で隔離すべき)
    * インスタンス変数の作成を分離する
    * 脆い外部メッセージを隔離する
  * 引数の順番への依存を取り除く
    * 初期化の際の引数にハッシュを使う
    * 明示的にデフォルト値を設定する(fetchメソッドが||に勝る)
    * 複数のパラメーターを用いた初期化を隔離する
* 依存方向の管理　→　自分より変更されないものに依存しなさい
  * 依存関係の逆転
  * 依存方向の選択
    * あるクラスは、ほかのクラスよりも要件が変わりやすい
    * 具象クラスは、抽象クラスよりも変わる可能性が高い
    * 多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ

---

第4章　柔軟なインターフェースをつくる
* インターフェースを定義する
  * パブリックインターフェース
    * クラスの主要な責任を明らかにする
    * 外部から実行されることが想定される
    * 気まぐれに変更されない
    * 他者がそこに依存しても安全
    * テストで完全に文書化されている
  * プライベートインタフェース
    * 実装の詳細に関わる
    * ほかの(クラスの)オブジェクトから送られてくることは想定されていない
    * どんな理由でも変更され得る
    * 他者がそこに依存するのは危険
    * テストでは言及されないこともある
  * 責任、依存関係、そしてインターフェース
    * パブリックメソッドはクラスの責任の説明として解釈できるものであるべき
* パブリックインターフェースを見つける
  * 見当をつける
    * ドメインオブジェクト：大きくて目に見える現実世界のものを表し、かつ最終的にデータベースに表されるもの
  * シーケンス図をつかう
    * クラスに基づく設計→メッセージに基づく設計
    * オブジェクトが存在するからメッセージを送るのではなく、メッセージを送るためにオブジェクトが存在する
  * 「どのように」を伝えるのではなく「何を」を頼む
    * パブリックインターフェースが小さいということは、ほかのところから依存されるメソッドがわずかしかないことを意味する
  * コンテキストの独立を模索する
    * オブジェクトが要求するコンテキストは、オブジェクトの再利用がどれだけ難しいかに直接関わる
  * ほかのオブジェクトを信頼する
  * オブジェクトを見つけるためにメッセージを使う
  * メッセージを基本とするアプリケーションをつくる
* 一番良い面(インターフェース)を表に出すコードを書く
  * インターフェースの明快さは、設計スキルをあらわにする
  * 明示的なインターフェースをつくる
    * 明示的にパブリックなインターフェースだと特定できる
    * 「どのように」よりも「何を」になっている
    * 名前は、考えられる限り、変わり得ないものである
    * オプション引数としてハッシュをとる
  * private, protected, publicキーワードはアクセスを拒否するのではなく、アクセスを大変にする
  * 上記キーワードを使うことで以下のことを伝えられる
    * 「将来の」プログラマーが持つ情報よりも、今の自分の方がより良い情報を持っていると信じている
    * 今の自分が不安定だと考えているメソッドを、将来のプログラマーに不用意に使われることは防がなければならないと信じている
  * 他のパブリックインターフェースに敬意を払う
  * プライベートインターフェースに依存するときは、注意深く
    * プライベートインターフェースに依存しなければならない場合は、適切に隔離する
  * コンテキストを最小限にする
    * メッセージの送り手が、クラスがどのようにその振る舞いを実装しているかを知ることなく、求めているものを得られるようにつくる
* デメテルの法則
  * デメテルを定義する
    * メッセージを送ることができるオブジェクトの集合を制限する
      * メソッドチェーンを重ねない
  * 法則を違反することによる影響
  * 違反を回避する
    * 例えば委譲を使い「ドット」を避ける
  * デメテルに耳を傾ける
    * デメテルの法則違反は、パブリックインターフェースが欠けているオブジェクトがあるのではないか、というヒントになる

---

### 第5章　ダックタイピングでコストを削減する
* ダックタイピングを理解する
* ダックを信頼するコードを書く
  * 隠れたダックを認識する
    * クラスで分岐するcase文
    * kind_of?とis_a?
    * responds_to?
  * ダックタイプを文書化する
    * ダックタイプをつくるときは、そのパブリックインターフェースの文書化とテストを、両方ともしなければならない
  * 賢くダックを選ぶ
    * 自分の手で書いたクラスをまたぐダックタイプを実装するのと、新たなダックタイプを導入するためにRubyの基本クラスを変更するのとでは大きな違いがある
* ダックタイピングへの恐れを克服する
  * 静的型付けによるダックタイプの無効化
  * 静的型付けと動的型付け
    * 静的型付けの利点
      * コンパイラがコンパイル時にエラーを発見してくれる
      * 可視化された型情報は文書の役割も果たしてくれる
      * コンパイルされたコードは最適化され、高速に動作する
    * 動的型付けの利点
      * コードは逐次実行され、動的に読み込まれる。そのため、コンパイル/makeのサイクルがない
      * ソースコードは明示的な型情報を含まない
      * メタプログラミングがより簡単
  * 動的型付けを受け入れる
    * コンパイラは不慮の型エラーからプログラマーを救うことはできない(キャストした途端、すべてが白紙に戻る)
    * コンパイル時の型検査は、コストが高い割にわずかな価値しか得られない
* まとめ
  * メッセージこそがオブジェクト指向アプリケーションの中心にあるもの
  * メッセージはパブリックインターフェースを介し、オブジェクト間で交換される
  * ダックタイピングは、これらのパブリックインターフェースを特定のクラスから切り離し、何であるかではなく何をするかによって定義される、共通の型をつくる
  * ダックタイピングという抽象に依存することによって、リスクは低減され、柔軟性が高まる

---

### 第6章　継承によって振る舞いを獲得する
* 継承を使うべき箇所を識別する
    * 具象クラスからはじめる
    * 複数の型を埋め込む
        * オブジェクトが受け手の分類に基づき、何のメッセージを送るかを決定しているパターンには注意が必要
    * 埋め込まれた型を見つける
        * typeやcategoryという名前で置き換えられる変数で分岐処理をつくっているなら、クラスを使う時かもしれない
        * 相違はあるけれど、関連はしている型を内包している単一のクラスがあるなら、継承を使う時かもしれない
    * 継承を選択する
        * ダックタイプがコード共有のために使うのはRubyのモジュール
        * サブクラスはスーパークラスを特化したもの
    * 継承関係を描く
        * サブクラスからスーパークラスに対して矢印を引く
* 抽象を見つける
    * 継承のルール
        * モデル化しているオブジェクトが「一般 - 特殊」の関係をしっかりと持っていること
        * 正しいコーディングテクニックを使っていること
    * 抽象的なスーパークラスをつくる
        * 抽象：いかなる特定のインスタンスからも離れている
        * 抽象クラスはサブクラスがつくられるために存在する
    * 抽象的な振る舞いを昇格する
        * 継承の難しさの多くは、抽象から具象を厳密に分けることに失敗することによって生じる
        * 「抽象的な振る舞いを昇格する」手順であれば、具象的な人工物を残してしまう恐れもなく、抽象的な部分を注意深く特定し昇格させることができる
        * 「間違っていたときに何がおこるだろう」と考える → 昇格の失敗によって生じる問題は単純
        * 一般的なルール：新たな継承の階層構造へとリファクタリングする際は、抽象を昇格できるようにコードを構成すべきであり、具象を降格するような構成にはすべきでない
    * 具象から抽象を分ける
    * テンプレートメソッドパターンを使う
        * スーパークラス内で基本の構造を定義し、サブクラス固有の特徴を得るためにメッセージを送る
    * すべてのテンプレートメソッドを実装する
        * テンプレートメソッドの要件は、有用なエラーを発生させる、合致するメソッドを実装することで常に文書化する
* スーパークラスとサブクラス間の結合度を管理する
    * 結合度を理解する
        * サブクラスはスーパークラスとどう関わるかまで知るべきではない(すべてのサブクラスで同じ箇所でsuperを呼び出すなど)
    * フックメッセージを使ってサブクラスを疎結合にする
        * サブクラスにアルゴリズムを知ることを許しsuperを送らせるのではなく、スーパークラスが代わりにフックメッセージを送る
* まとめ
    * 継承によって、共有するコードを隔離でき、共通のアルゴリズムを抽象クラスに実装できる
    * 抽象的なスーパークラスをつくるために一番良い方法は、具象的なサブクラスからコードを押し上げること
    * 抽象スーパークラスはテンプレートメソッドパターンを使うことでその継承者に専門的に特化することを促す
    * 抽象スーパークラスはフックメソッドを使うことでsuperの送信を強制せずとも継承者がスーパークラスに特化を提供できるようにする

---

### 第7章　モジュールでロールの振る舞いを共有する

* ロールを理解する
  * 不必要な依存関係を取り除く
    * オブジェクト自身に自身を語らせる
      * 自身の振る舞いは自身で持つべき
    * 抽象を抽出する
      * クラスによる継承「である(is-a)」とモジュールによるコード共有「のように振る舞う(behaves-like-a)」は似ているが違う
* 継承可能なコードを書く
  * アンチパターン
    * オブジェクトがtypeやcategoryという変数名を使い、どんなメッセージをselfに送るか決めているパターン
    * メッセージを受け取るオブジェクトのクラスを確認してから、どのメッセージを送るかをオブジェクトが決めているパターン
  * 抽象に固執する
    * 抽象スーパークラス内のコードを使わないサブクラスがあってはならない
  * 契約を守る
    * サブクラスはスーパークラスのインターフェースに含まれるどのメッセージがきても応えられる応えられるべきであり、同じ種類の入力をとり、同じ種類の出力を行わなければならない
  * テンプレートメソッドパターンを使う
    * 抽象を具象から分けることができる
    * アルゴリズムのうち変化する場所を表す
    * 抽象コードでアルゴリズムを定義し、抽象を継承する具象でテンプレート化されたメソッドをオーバーライドすることで特化を行う
  * 前もって疎結合にする
    * 継承する側でsuperを呼び出すようなコードを書くのは避ける
    * フックメッセージを使えば抽象クラスのアルゴリズムを知っておく責任からは解放されながらも、アルゴリズムに加わることはできる
  * 階層構造は浅くする
    * 階層構造が深いとフックメッセージが使えない
    * 階層構造が深いとその分だけ大量の依存をはじめから持つことになる
* まとめ
  * オブジェクトが共通のロールを担うためには、振る舞いを共有する必要があり、そのためにはRubyのモジュールが役立つ
  * モジュールでもクラスと同様に、テンプレートメソッドパターンを使い、includeする側のオブジェクトが自然と特化するよう仕向けるべき
  * includeする側にsuperの送信を強制することを避けるためにもフックメソッドを実装する
  * リスコフの置換原則：「派生型は上位型と置換可能であるべき」=「オブジェクトは自信が主張するとおりに振る舞うべき」

---

### 第8章　コンポジションでオブジェクトを組み合わせる
コンポジション：組み合わされた全体が、単なる部品の集合以上となるように、個別の部品を複雑な全体へと組み合わせる(コンポーズする)行為

* コンポジションと継承の選択
  * クラスによる継承：オブジェクトを階層構造に構成するコストを払う代わりに、メッセージの委譲は無料で手に入れられる
  * コンポジション：オブジェクトを構造的に独立して存在させる代わりに、明示的なメッセージ委譲のコストを払う
  * 直面した問題がコンポジションによって解決できるものであれば、コンポジションで解決することを優先するべき
    * コンポジションが持つ依存は、継承が持つ依存よりもはるかに少ない
  * 継承による影響を認める
    * 継承の利点
      * 継承を使った結果得られるコードは「オープン・クローズド(Open-Closed)」と特徴づけられる → 拡張には開いており(open)、修正には閉じている(closed)
    * 継承のコスト
      * 継承が適さない問題に対して、誤って継承を選択してしまう
      * 問題に対して継承の適用が妥当であったとしても、自分が書いているコードがほかのプログラマーによって、まったく予期していない目的のために使われるかもしれない
      * 継承は、その定義からして深く埋め込まれた依存の集まりを伴うもの
  * コンポジションの影響を認める
    * コンポジションの利点
      * 責任が単純明快であり、明確に定義されたインターフェースを介してアクセス可能な小さなオブジェクトがいくつもつくられる
    * コンポジションのコスト
      * それぞれの部品は小さく、かんたんに理解できるものであったとしても、組み合わせられた全体の動作は理解しやすいとはいえない
      * コンポーズされたオブジェクトは、明示的にどのメッセージをだれに委譲するかを必ず知っていなければならない
    * 関係の選択
      * 継承とは特殊化
      * 継承が最も適しているのは、過去のコードの大部分を使いつつ、新たなコードの追加が比較的少量の時に、既存のクラスに機能を追加する場合
      * 振る舞いが、それを構成するパーツの総和を上回るのなら、コンポジションを使う
      * is-a関係に継承を使う
      * behaves-like-a関係にダックタイプを使う
      * has-a関係にコンポジションを使う

---

### 第9章　費用対効果の高いテストを設計する
* 意図を持ったテスト
  * テストの意図を知る
    * バグを見つける
      * バグの初期段階での修正は、いつでもコストの削減になる
    * 仕様書となる
    * 設計の決定を遅らせる
      * テストがインターフェースに依存している場合、その根底にあるコードは奔放にリファクタリングできる
      * 意図的にインターフェースに依存することによって、テストを使い、設計の決定を安全に、かつ代償もなく遅らせることができる
    * 抽象を支える
      * コードベースが拡大し、いくつもの抽象が育っていくと、テストの重要性もいっそう増す
    * 設計の欠陥を明らかにする
      * テストのセットアップに苦痛が伴うのであれば、コードはコンテキストを要求しすぎている
      * 問題となることのみをテストする、疎結合のテストを書く
  * 何をテストするかを知る
    * 貪欲すぎるテストは、アプリケーション全体の正しさについて何も証明しないどころか、リファクタするたびに毎回壊れるせいでコストを高める
    * テストはオブジェクトの境界に入ってくる(受信する)か、出ていく(送信する)メッセージに集中すべき
    * 受信メッセージは、その戻り値の状態がテストされるべき
    * 送信コマンドメッセージは、送られたことがテストされるべき
    * 送信クエリメッセージは、テストするべきではない
  * いつテストをするかを知る
    * 適切な時間に、適切な量で終われば、テストをすることと、テストファーストでコードを書くことは、全体的なコストを下げる
    * 経験豊富な設計者は問題に対して「スパイクを打つ」ということを知っている
    * スパイクを打つ：コードだけを書き実験する
  * テストの方法を知る
    * テスティングフレームワーク(MiniTest vs RSpec)
    * テスト駆動開発(TDD) vs 振る舞い駆動開発(BDD)
* 受信メッセージをテストする
  * 使われていないインターフェースを削除する
    * 依存されていないメッセージのテストをしてはいけないし、そのメッセージは削除すべき
  * クラスを使って依存オブジェクトを注入する
    * クラスがロールを担う唯一のクラスで、十分に速いのであれば、そのクラスを使って依存オブジェクトを注入すべき
  * ロールとして依存オブジェクトを注入する
    * 「依存オブジェクトの注入」の本質は、それにより、既存のコードを変更することなく異なる具象クラスへの差し替えができるようになる
    * オブジェクト指向設計が依存オブジェクトの注入を勧めるのは、具象クラスは一連のロールよりも多様になると信じているから
  * テストダブルをつくる
    * テストダブル：ロールの担い手を様式化したインスタンスであり、テストでのみ使われるもの
    * 関心のある機能を1つ強調し、オブジェクトのほかの詳細は背景へと減退させる
  * テストを使ってロールを文書化する
    * ロールにはそれ自体のテストが必要
* プライベートメソッドをテストする
  * テスト中ではプライベートメソッドを無視する
  * テスト対象クラスからプライベートメソッドを取り除く
    * プライベートメソッドが一つもなければ、そのテストの心配をする必要もない
    * プライベートメソッドを新しいオブジェクトに切り出すことを考える
  * プライベートメソッドのテストをするという選択
* 送信メッセージをテストする
  * クエリメッセージ(副作用のないメッセージ)を無視する
