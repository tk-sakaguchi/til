### 第1章　オブジェクト指向設計

* オブジェクト指向設計とは「依存関係を管理すること」
* 設計の目的は「あとにでも」設計をできるようにすることであり、その第一目標は変更コストの削減
* SOLID
  * 単一責任(Single Responsibility)
  * オープン・クローズド
  * リスコフの置換(Liskov Substitution)
  * インターフェース分離(Interface Segregation)
  * 依存性逆転(Dependency Inversion)
* DRY(Don't Repeat Yourself)
* デメテルの法則
* 設計(デザイン)パターン
  * オブジェクト指向ソフトウェア設計におあて遭遇するさまざまな問題に対して、簡単でかつ明瞭な解を与える
  * 設計プロダクトの柔軟性、モジュール性、再利用性、および理解のしやすさをより高める

### 第2章　単一責任のクラスを設計する

* 設計とはアプリケーションの可変性を保つために技巧を凝らすことであり、完璧を目指すことではない
* 自身の書くコードには次の性質が伴うべき
  * 見通しがいい(Transparent)：変更するコードにおいても、そのコードに依存する別の場所のコードにおいても、その影響範囲が明白である
  * 合理的(Reasonable)：どんな変更であっても、かかるコストは変更がもたらす利益にふさわしい
  * 利用性が高い(Usable)：新しい環境、予期していなかった環境でも再利用できる
  * 模範的(Exemplary)：コードに変更を加える人が、上記の品質を自然と保つようなコードになっている
* 凝縮度：クラス内のすべてがそのクラスの中心的な目的に関連していればそのクラスは凝縮度が高い、もしくは、単一責任であると言われる
* 単一責任のメソッドがもたらす恩恵
  * 隠蔽されていた性質を明らかにする
  * コメントをする必要がない
  * 再利用を促進する
  * ほかのクラスへの移動が簡単

### 第3章　依存関係を管理する
* オブジェクトが次のものを知っているとき、オブジェクトには依存関係がある
  * ほかのクラスの名前
  * self以外のどこかに送ろうとするメッセージの名前
  * メッセージが要求する引数
  * それらの引数の順番
* ほかの依存関係
  * 「『何かを知るオブジェクト』を知るオブジェクト」を知るオブジェクトがあるとき
    * いくつものメッセージをチェーンでつなぐ場合など
  * テストからコードへの過度な結合
* 疎結合なコードを書く
  * 依存オブジェクトの注入
  * 依存を隔離する(不必要な依存を除去できないなら、クラス内で隔離すべき)
    * インスタンス変数の作成を分離する
    * 脆い外部メッセージを隔離する
  * 引数の順番への依存を取り除く
    * 初期化の際の引数にハッシュを使う
    * 明示的にデフォルト値を設定する(fetchメソッドが||に勝る)
    * 複数のパラメーターを用いた初期化を隔離する
* 依存方向の管理　→　自分より変更されないものに依存しなさい
  * 依存関係の逆転
  * 依存方向の選択
    * あるクラスは、ほかのクラスよりも要件が変わりやすい
    * 具象クラスは、抽象クラスよりも変わる可能性が高い
    * 多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ

第4章　柔軟なインターフェースをつくる
* インターフェースを定義する
  * パブリックインターフェース
    * クラスの主要な責任を明らかにする
    * 外部から実行されることが想定される
    * 気まぐれに変更されない
    * 他者がそこに依存しても安全
    * テストで完全に文書化されている
  * プライベートインタフェース
    * 実装の詳細に関わる
    * ほかの(クラスの)オブジェクトから送られてくることは想定されていない
    * どんな理由でも変更され得る
    * 他者がそこに依存するのは危険
    * テストでは言及されないこともある
  * 責任、依存関係、そしてインターフェース
    * パブリックメソッドはクラスの責任の説明として解釈できるものであるべき
* パブリックインターフェースを見つける
  * 見当をつける
    * ドメインオブジェクト：大きくて目に見える現実世界のものを表し、かつ最終的にデータベースに表されるもの
  * シーケンス図をつかう
    * クラスに基づく設計→メッセージに基づく設計
    * オブジェクトが存在するからメッセージを送るのではなく、メッセージを送るためにオブジェクトが存在する
  * 「どのように」を伝えるのではなく「何を」を頼む
    * パブリックインターフェースが小さいということは、ほかのところから依存されるメソッドがわずかしかないことを意味する
  * コンテキストの独立を模索する
    * オブジェクトが要求するコンテキストは、オブジェクトの再利用がどれだけ難しいかに直接関わる
  * ほかのオブジェクトを信頼する
  * オブジェクトを見つけるためにメッセージを使う
  * メッセージを基本とするアプリケーションをつくる
* 一番良い面(インターフェース)を表に出すコードを書く
  * インターフェースの明快さは、設計スキルをあらわにする
  * 明示的なインターフェースをつくる
    * 明示的にパブリックなインターフェースだと特定できる
    * 「どのように」よりも「何を」になっている
    * 名前は、考えられる限り、変わり得ないものである
    * オプション引数としてハッシュをとる
  * private, protected, publicキーワードはアクセスを拒否するのではなく、アクセスを大変にする
  * 上記キーワードを使うことで以下のことを伝えられる
    * 「将来の」プログラマーが持つ情報よりも、今の自分の方がより良い情報を持っていると信じている
    * 今の自分が不安定だと考えているメソッドを、将来のプログラマーに不用意に使われることは防がなければならないと信じている
  * 他のパブリックインターフェースに敬意を払う
  * プライベートインターフェースに依存するときは、注意深く
    * プライベートインターフェースに依存しなければならない場合は、適切に隔離する
  * コンテキストを最小限にする
    * メッセージの送り手が、クラスがどのようにその振る舞いを実装しているかを知ることなく、求めているものを得られるようにつくる
* デメテルの法則
  * デメテルを定義する
    * メッセージを送ることができるオブジェクトの集合を制限する
      * メソッドチェーンを重ねない
  * 法則を違反することによる影響
  * 違反を回避する
    * 例えば委譲を使い「ドット」を避ける
  * デメテルに耳を傾ける
    * デメテルの法則違反は、パブリックインターフェースが欠けているオブジェクトがあるのではないか、というヒントになる
