## 第1章 ゼロの物語 -「ない」ものが「ある」ことの意味
* コンピュータで2進法が使われている理由
  * スイッチが切れている状態 ... 0
  * スイッチが入っている状態 ... 1
  * 上記のように1つのスイッチがあれば0か1かのどちらかを表現でき、スイッチの個数を増やしていけば、どんなに大きな数でも表現できる
  * 10進法に比べて桁が多くなってしまうが、コンピュータは高速に計算できるため、桁の多さを気にしない
* 位取り記数法
  * 位取り記数法とは
    * N進法
      * 使われる数字は、0, 1, 2, 3, ..., N-1のN種類
      * 右から順に、N⁰の位、N¹の位、N²の位、N³の位、...になる(基数はN)
  * 位取り記数法を使わないローマ数字
    * 位は意味を持たず、数字そのものがその数を示す
    * ゼロがない
    * Ⅰ(1), V(5), X(10), L(50), C(100), D(500), M(1000)の文字を使う
    * 並べた文字が表す数を加えたものが、全体の数になる
* 指数法則
  * 10の0乗は何か
    * 指数が1減ると、全体は10分の1になると考える
* 0の果たす役割
  * 場所を確保する
    * 2503の0は10の位が「ない」ことを表す
  * パターンを作り出し、ルールをシンプルにする
* 人間の限界と構造の発見
  * 数が大きくなってくると扱いが難しくなる → 大きな問題は小さな「まとまり」に分けて解く

## 第2章 論理 - trueとfalseの2分割
* 複雑な命題を組み立てる
  * 否定 - Aではない
  * 論理積 - AかつB
  * 論理和 - AまたはB
  * 排他的論理和 - AまたはB(でも両方ではない)
  * 等値 - AとBは等しい
  * 含意 - AならばB
    * 前提条件であるAがfalseであれば、Bの真偽によらず「AならばB」の値はtrueになる
    * 「Aの中にいるならば、絶対にBの中にいなければならない」
* ド・モルガンの法則
  * 「Aではない」または「Bではない」というのは「AかつB」ではないことに等しい
  * 「Aではない」かつ「Bではない」というのは「AまたはB」ではないことに等しい
* カルノー図
  * 全命題の真偽の組み合わせを2次元的に表した図
* 未定義を含む論理
  * 条件付き論理積(&&)
    * 「A&&B」はAという条件によってBを調べるかどうかを判断している
  * 条件付き論理和(||)
  * 3値論理でのド・モルガンの法則
    * (!A) || (!B) = !(A && B)
    * (!A) && (!B) = !(A || B)

## 第3章 剰余 - 周期性とグループ分け
* 剰余の力 - 大きな数を割り算1回でグループ分け
  * 周期性を見つけることができれば、剰余の力を使って大きな数をねじ伏せることができる
  * 剰余は周期性を活用するための道具
  * 剰余の結果が同じになるかどうかで、たくさんのものをグループ分けできる

## 第4章 数学的帰納法 - 無数のドミノを倒すには
* 数学的帰納法とは
  * 整数についての主張を、0以上のすべての整数nについて証明するときに用いる手法
  * 数学的帰納法では証明にかかる時間を度外視する -> 数学とプログラミングの大きな違い
* 証明を行う際の2つのステップ
  * ステップ1(基底)：「P(0)が成り立つ」ことを証明する
  * ステップ2(帰納)：0以上のどんな整数kを選んでも、「P(k)が成り立つならば、P(k+1)も成り立つ」ことを証明する
* ループ不変条件(loop invariant)
  * ループの各回で成り立っている論理式

## 第5章 順列・組み合わせ - 数えないための法則
* 数えるとは
  * 自分が数えたいものを整数に対応付けること
* 和の法則
  * |A U B| = |A| + |B|
  * 和の法則が成り立つのは、集合の要素にだぶりがない場合だけ
* 包含と排除の原理
  * |A U B| = |A| + |B| - |A ∩ B|
  * だぶりのことを考慮した和の法則
* 積の法則
  * |A x B| = |A| x |B|
* 置換
  * n個のものを順序を考えて並べること
* 階乗
  * 5! = 5 x 4 x 3 x 2 x 1
  * 0! = 1
* 順列
  * 順番を考えて並べる
  * nPk = n x (n - 1) x (n - 2) x ... x (n - k + 1)
  * nPk = n! / (n - k)!
  * nPo = 1
* 組み合わせ
  * 順番を考えずに選び出す
  * まず順番を考えて数え、後から重複度で割る
  * nCk = n! / (n - k)!k!
  * nCk = nPk / kPk
  * nCo = 1

## 第6章 - 自分で自分を定義する
* 再帰的な構造を見つけ出す
  * 「大きい問題を、一回り小さい問題を使って表現できないだろか」と考える → 再帰的な構造を見つけ出す
  * 再帰的な構造を元にして漸化式を立てる
